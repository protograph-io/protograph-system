export var GRAMMAR_INSERTS = {
    "COMMAND_EXTENSION_NAMES": "COMMAND_EXTENSION_NAMES",
    "COMMAND_EXTENSION_declarationS": "COMMAND_EXTENSION_declarationS",
    "OBJECT_EXTENSION_NAMES": "OBJECT_EXTENSION_NAMES",
    "OBJECT_EXTENSION_declarationS": "OBJECT_EXTENSION_declarationS",
    "QUERY_OBJECT_EXTENSION_NAMES": "QUERY_OBJECT_EXTENSION_NAMES",
    "QUERY_OBJECT_EXTENSION_declarationS": "QUERY_OBJECT_EXTENSION_declarationS",
    "QUERY_EXTENSION_declarationS": "QUERY_EXTENSION_declarationS"
};
var helpers = "\n\n/******************\n*   Helpers     *\n******************/\n\n\nrange = \"range(\"i sp* start:dynamic_number sp* \",\" sp* end:dynamic_number sp* \",\" sp* step:dynamic_number sp* \")\"  {return {start, end, step}}\n\t/ \"range(\"i sp* start:dynamic_number sp* \",\" sp* end:dynamic_number sp* \")\"  {return {start, end, step: null}}\n    / \"range(\"i sp* end:dynamic_number sp* \")\" {return {start: null, end, step: null}}\n\narray \"Array (1-dim)\" = array_parentheses / array_brackets\narray_parentheses \"Array ()\" = \"(\"  sp*  vs:(v:dynamic_value sp* \",\" sp* {return v})* v2:dynamic_value  sp*  \")\" {return [...vs, v2].filter(item => item !== undefined && item !== null && item !== \"\")}\narray_brackets \"Array []\" = \"[\"  sp*  vs:(v:dynamic_value sp* \",\" sp* {return v})* v2:dynamic_value  sp*  \"]\" {return [...vs, v2].filter(item => item !== undefined && item !== null && item !== \"\")}\n\ndynamic_number = Float / Integer / d:number {return parseInt(d,10)}\ndynamic_value = dynamic_single_value /  d:(w:anyword_unsafe sp* {return w})* {return d.flat().join(\" \")}\ndynamic_single_value = boolean / Float / Integer / d:number {return parseInt(d,10)} /anyword_unsafe / null / undefined\nboolean \"Boolean\" = d:(\"true\"i / \"false\"i) {return d.toLowerCase() === \"true\"}\nnull \"Null\" = \"null\"i {return null}\nundefined \"Undefined\" = \"undefined\"i {return undefined}\n\nprotected \"Protected Word\" = step / object_query_extensions\nanyword \"Word\" = String / !protected anyword_unsafe {return text()}\nanyword_unsafe \"Word/Number/Combination\" = String / [a-zA-Z0-9-]+ {return text()} / Float / Integer / number {return text()}\nnumber \"Number\" = [0-9]+ {return text()}\nword \"Single Word\" = [a-zA-Z]+ {return text()}\nempty_line \"Empty Line\" = ((sp / tab) * (enterkey)) {return undefined} / sp+ EOL {return undefined} \ntab \"Tab\" = \"\\t\" / sp sp sp sp / sp sp\nEOL \"End of Line\" = (sp)* enterkey / (sp)* !.\nsp \"Space\" = \" \"\nenterkey = \"\\n\" / \"\\r\" \"\\n\" ?\n_ \"whitespace\"\n    = [ \\t\\n\\r]*\n\nInteger \"integer\"\n  = n:[0-9]+ {\n    return parseInt(n.join(\"\"));\n  }\n\nFloat \"float\"\n  = neg:(\"-\" {return true})? left:Integer \".\" right:Integer {\n    return parseFloat([\n      left.toString(),\n      right.toString()\n    ].join(\".\")) * ((neg) ? -1 : 1);\n  }\n\n    \n/*https://stackoverflow.com/questions/33947960/allowing-for-quotes-and-unicode-in-peg-js-grammar-definitions*/\nString\n\t= '\"' chars:DoubleStringCharacter* '\"' { return chars.join(''); }\n\t/ \"'\" chars:SingleStringCharacter* \"'\" { return chars.join(''); }\n\nDoubleStringCharacter\n\t= !('\"' / \"\\\\\") char:. { return char; }\n\t/ \"\\\\\" sequence:EscapeSequence { return sequence; }\n\nSingleStringCharacter\n\t= !(\"'\" / \"\\\\\") char:. { return char; }\n\t/ \"\\\\\" sequence:EscapeSequence { return sequence; }\n\nEscapeSequence\n\t= \"'\"\n\t/ '\"'\n\t/ \"\\\\\"\n\t/ \"b\"  { return \"\\b\";   }\n\t/ \"f\"  { return \"\\f\";   }\n\t/ \"n\"  { return \"\\n\";   }\n\t/ \"r\"  { return \"\\r\";   }\n\t/ \"t\"  { return \"\\t\";   }\n\t/ \"v\"  { return \"\\x0B\"; }\n\n\ncomment \"Comment\" = _ p:(single / multi) {return null}\nsingle \"Single Line Comment\" = '//' p:([^\\n]*) {return p.join('')} / '#' p:([^\\n]*) {return p.join('')}\nmulti \"Multi Line Comment\" = \"/*\" inner:(!\"*/\" i:. {return i})* \"*/\" {return inner.join('')}\n";
export var base = "\n{\n\tfunction findNewLines(lines) {\n\t\treturn lines.reduce((agg, item, index) => (!item || !!item.prune) ? [...agg,{index, raw: item.raw}] : agg,[])\n\t}\n    function filterCodeLine(line) {\n    \treturn Boolean(line) && (!(\"prune\" in line) || !line.prune)\n    }\n}\n\n\n/******************\n*   Structure     *\n******************/\n\n/* step makes everything between step a grouped item in an array */\n/* IMPORTANT: make sure \"step\" is not command */\nstart \n\t= s:( \n\t\ta:code_line * (step EOL) {return {data:a.filter(filterCodeLine), newlines: findNewLines(a), location: location()}} \n\t\t/ a:code_line + {return {data:a.filter(filterCodeLine), newlines: findNewLines(a), location: location()}} \n\t)*  {return s.filter(i => i.data.length)}\n\n/* code_line's first case allows there to be empty lines */\ncode_line = empty_line {return {prune: true, raw: text()}} / statement_with_properties / comment {return {prune: true, raw: text()}}\n\nstatement = val:(command / object_query / query) {return {...val, raw: text()}}\n\n\nstatement_with_properties = s:statement EOL vals:(collection_properties *) {\n\treturn {\n\t    ...s,\n        properties: vals.reduce((agg,item) => ({...agg,...item}),{}),\n\t\tlocation: location(),\n\t\traw: text()\n    }\n}\ncollection_properties = tab p:((k:property sp? \":\" sp? v:value {return[k,v]}) / k:property {return [k,null]}) sp* EOL {return {[p[0]]:p[1]}}\nproperty \"Property Key\" = anyword_unsafe \n/*Allows multiple spaced words with or without quotes*/\nvalue \"Property Value (Space Seperated Words)\" = dynamic_value\n\n/* IMPORTANT: make sure \"step\" is not command */\nprotected_commands = step\nstep \"Step\" = \"step\"i\n\n\n\n/******************\n*   Objects.      *\n******************/\n\n\nobject_query \"Object/Structure\" = object_query_extensions \n\nobject_query_extensions = " + GRAMMAR_INSERTS.OBJECT_EXTENSION_NAMES + "\n\n/* Objects Extensions Defined */\n\n" + GRAMMAR_INSERTS.OBJECT_EXTENSION_declarationS + "\n\n\n/******************\n*   Queries       *\n******************/\n\n\nquery \"Query\" = query_objects\n\nquery_objects = query_object_extensions\n\nquery_object_extensions = " + GRAMMAR_INSERTS.QUERY_OBJECT_EXTENSION_NAMES + "\n\n\n/* Queries Extensions */\n\n" + GRAMMAR_INSERTS.QUERY_OBJECT_EXTENSION_declarationS + "\n\n/* Queries Extensions Defined */\n\n" + GRAMMAR_INSERTS.QUERY_EXTENSION_declarationS + "\n\n\n\n/******************\n*   Commands      *\n******************/\n\n\ncommand \"Command\"\n\t= !protected_commands c:command_extensions { return {type: \"command\", ...c} }\n\n\n/* Commands Extensions */\n\ncommand_extensions = " + GRAMMAR_INSERTS.COMMAND_EXTENSION_NAMES + "\n\n\n/* Commands Extensions Defined */\n\n" + GRAMMAR_INSERTS.COMMAND_EXTENSION_declarationS + "\n\n\n\n\n/******************\n*   Extensions    *\n******************/\n\n\n\n" + helpers + "\n";
